<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MindFlow - AI æ™ºèƒ½å¿ƒæ™ºåœ–</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft JhengHei', 'å¾®è»Ÿæ­£é»‘é«”', sans-serif;
            background: #1a1a2e;
            overflow: hidden;
            color: #fff;
        }

        #header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(26, 26, 46, 0.95);
            backdrop-filter: blur(10px);
            padding: 15px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 1000;
            border-bottom: 2px solid rgba(102, 126, 234, 0.3);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .logo {
            font-size: 1.8rem;
            font-weight: 700;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 25px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            box-shadow: none;
        }

        .btn-danger {
            background: linear-gradient(45deg, #f093fb, #f5576c);
        }

        .btn-success {
            background: linear-gradient(45deg, #4facfe, #00f2fe);
        }

        #canvas-container {
            position: fixed;
            top: 70px;
            left: 0;
            right: 0;
            bottom: 0;
            overflow: hidden;
        }

        #canvas {
            cursor: grab;
            background: radial-gradient(circle at 50% 50%, #1a1a2e 0%, #0f0f1e 100%);
        }

        #canvas:active {
            cursor: grabbing;
        }

        .sidebar {
            position: fixed;
            right: -350px;
            top: 70px;
            bottom: 0;
            width: 350px;
            background: rgba(26, 26, 46, 0.95);
            backdrop-filter: blur(10px);
            padding: 30px;
            transition: right 0.3s ease;
            z-index: 999;
            border-left: 2px solid rgba(102, 126, 234, 0.3);
            overflow-y: auto;
        }

        .sidebar.open {
            right: 0;
        }

        .sidebar h3 {
            margin-bottom: 20px;
            color: #667eea;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            color: #aaa;
            font-size: 0.9rem;
        }

        .form-group input,
        .form-group select,
        .form-group textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid rgba(102, 126, 234, 0.3);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.05);
            color: white;
            font-family: inherit;
        }

        .form-group textarea {
            resize: vertical;
            min-height: 80px;
        }

        #stats {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(26, 26, 46, 0.9);
            backdrop-filter: blur(10px);
            padding: 15px 20px;
            border-radius: 15px;
            border: 1px solid rgba(102, 126, 234, 0.3);
            font-size: 0.9rem;
            z-index: 998;
        }

        .stat-item {
            margin: 5px 0;
            color: #aaa;
        }

        .stat-value {
            color: #667eea;
            font-weight: 600;
        }

        #tutorial {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(102, 126, 234, 0.9);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 15px;
            max-width: 300px;
            z-index: 998;
            animation: slideInRight 0.5s ease;
        }

        #tutorial h4 {
            margin-bottom: 10px;
            font-size: 1.1rem;
        }

        #tutorial ul {
            list-style: none;
            font-size: 0.85rem;
            line-height: 1.8;
        }

        #tutorial li:before {
            content: "âœ¦ ";
            color: #fff;
        }

        .close-tutorial {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: background 0.3s ease;
        }

        .close-tutorial:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        @keyframes slideInRight {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .color-picker {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .color-option {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.3s ease;
        }

        .color-option:hover {
            transform: scale(1.1);
            border-color: white;
        }

        .color-option.selected {
            border-color: white;
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.5);
        }

        @media (max-width: 768px) {
            #header {
                padding: 10px 15px;
            }

            .logo {
                font-size: 1.3rem;
            }

            .btn {
                padding: 8px 15px;
                font-size: 0.8rem;
            }

            .sidebar {
                width: 100%;
                right: -100%;
            }

            #stats, #tutorial {
                font-size: 0.8rem;
                padding: 10px 15px;
            }
        }

        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.5rem;
            color: #667eea;
            z-index: 9999;
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
    </style>
</head>
<body>
    <div id="header">
        <div class="logo">ğŸ§  MindFlow</div>
        <div class="controls">
            <button class="btn" onclick="addNode()">â• æ–°å¢ç¯€é»</button>
            <button class="btn btn-success" onclick="autoLayout()">âœ¨ AI è‡ªå‹•æ’ç‰ˆ</button>
            <button class="btn btn-secondary" onclick="toggleSidebar()">âš™ï¸ è¨­å®š</button>
            <button class="btn btn-secondary" onclick="saveToFile()">ğŸ’¾ å„²å­˜</button>
            <button class="btn btn-secondary" onclick="loadFromFile()">ğŸ“‚ è¼‰å…¥</button>
            <button class="btn btn-secondary" onclick="exportImage()">ğŸ“¸ åŒ¯å‡ºåœ–ç‰‡</button>
            <button class="btn btn-danger" onclick="clearCanvas()">ğŸ—‘ï¸ æ¸…é™¤</button>
            <button class="btn btn-secondary" onclick="goHome()">ğŸ  é¦–é </button>
        </div>
    </div>

    <div id="canvas-container">
        <canvas id="canvas"></canvas>
    </div>

    <div id="sidebar" class="sidebar">
        <h3>ç¯€é»è¨­å®š</h3>
        <div class="form-group">
            <label>ç¯€é»æ–‡å­—</label>
            <textarea id="nodeText" placeholder="è¼¸å…¥ç¯€é»å…§å®¹..."></textarea>
        </div>
        <div class="form-group">
            <label>ç¯€é»é¡è‰²</label>
            <div class="color-picker">
                <div class="color-option" style="background: #667eea;" data-color="#667eea"></div>
                <div class="color-option" style="background: #764ba2;" data-color="#764ba2"></div>
                <div class="color-option" style="background: #f093fb;" data-color="#f093fb"></div>
                <div class="color-option" style="background: #4facfe;" data-color="#4facfe"></div>
                <div class="color-option" style="background: #43e97b;" data-color="#43e97b"></div>
                <div class="color-option" style="background: #fa709a;" data-color="#fa709a"></div>
                <div class="color-option" style="background: #feca57;" data-color="#feca57"></div>
                <div class="color-option" style="background: #ff6b6b;" data-color="#ff6b6b"></div>
            </div>
        </div>
        <div class="form-group">
            <label>ç¯€é»å¤§å°</label>
            <input type="range" id="nodeSize" min="20" max="100" value="50">
        </div>
        <div class="form-group">
            <button class="btn" style="width: 100%;" onclick="updateNode()">âœ… æ›´æ–°ç¯€é»</button>
        </div>
        <div class="form-group">
            <button class="btn btn-danger" style="width: 100%;" onclick="deleteNode()">ğŸ—‘ï¸ åˆªé™¤ç¯€é»</button>
        </div>
    </div>

    <div id="stats">
        <div class="stat-item">ç¯€é»æ•¸: <span class="stat-value" id="nodeCount">0</span></div>
        <div class="stat-item">é€£ç·šæ•¸: <span class="stat-value" id="edgeCount">0</span></div>
        <div class="stat-item">ç¸®æ”¾: <span class="stat-value" id="zoomLevel">100%</span></div>
    </div>

    <div id="tutorial">
        <button class="close-tutorial" onclick="closeTutorial()">Ã—</button>
        <h4>ğŸ’¡ ä½¿ç”¨èªªæ˜</h4>
        <ul>
            <li>é»æ“Šç©ºç™½è™•æ–°å¢ç¯€é»</li>
            <li>æ‹–æ›³ç¯€é»ä¾†ç§»å‹•</li>
            <li>é»æ“Šç¯€é»å¾ŒæŒ‰ä½Shiftå†é»æ“Šå¦ä¸€å€‹ç¯€é»å»ºç«‹é€£ç·š</li>
            <li>é›™æ“Šç¯€é»ç·¨è¼¯å…§å®¹</li>
            <li>æ»¾è¼ªç¸®æ”¾ç•«å¸ƒ</li>
            <li>æŒ‰ä½ç©ºç™½è™•æ‹–æ›³ç§»å‹•ç•«å¸ƒ</li>
            <li>æŒ‰Deleteéµåˆªé™¤é¸ä¸­çš„ç¯€é»</li>
        </ul>
    </div>

    <script>
        // Canvas setup
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let width = window.innerWidth;
        let height = window.innerHeight - 70;

        canvas.width = width;
        canvas.height = height;

        // Data structures
        let nodes = [];
        let edges = [];
        let selectedNode = null;
        let draggedNode = null;
        let connectMode = false;
        let connectStart = null;

        // Camera
        let camera = {
            x: 0,
            y: 0,
            zoom: 1
        };

        let isDraggingCanvas = false;
        let lastMouseX = 0;
        let lastMouseY = 0;

        // Node class
        class Node {
            constructor(x, y, text = 'æ–°ç¯€é»', color = '#667eea', radius = 50) {
                this.x = x;
                this.y = y;
                this.text = text;
                this.color = color;
                this.radius = radius;
                this.vx = 0;
                this.vy = 0;
                this.id = Math.random().toString(36).substr(2, 9);
            }

            draw() {
                ctx.save();

                // Shadow
                ctx.shadowColor = this.color;
                ctx.shadowBlur = selectedNode === this ? 30 : 15;

                // Gradient fill
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.radius);
                gradient.addColorStop(0, this.color);
                gradient.addColorStop(1, this.adjustColor(this.color, -40));

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();

                // Border
                if (selectedNode === this) {
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 4;
                    ctx.stroke();
                }

                // Text
                ctx.fillStyle = '#fff';
                ctx.font = `bold ${Math.max(12, this.radius / 3)}px Microsoft JhengHei`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.shadowBlur = 0;

                // Wrap text
                const words = this.text.split('');
                const maxWidth = this.radius * 1.5;
                let line = '';
                let lines = [];

                for (let char of words) {
                    const testLine = line + char;
                    const metrics = ctx.measureText(testLine);
                    if (metrics.width > maxWidth && line.length > 0) {
                        lines.push(line);
                        line = char;
                    } else {
                        line = testLine;
                    }
                }
                lines.push(line);

                const lineHeight = Math.max(16, this.radius / 2.5);
                const startY = this.y - (lines.length - 1) * lineHeight / 2;

                lines.forEach((line, i) => {
                    ctx.fillText(line, this.x, startY + i * lineHeight);
                });

                ctx.restore();
            }

            adjustColor(color, amount) {
                const num = parseInt(color.slice(1), 16);
                const r = Math.max(0, Math.min(255, (num >> 16) + amount));
                const g = Math.max(0, Math.min(255, ((num >> 8) & 0x00FF) + amount));
                const b = Math.max(0, Math.min(255, (num & 0x0000FF) + amount));
                return '#' + (0x1000000 + r * 0x10000 + g * 0x100 + b).toString(16).slice(1);
            }

            contains(x, y) {
                const dx = x - this.x;
                const dy = y - this.y;
                return dx * dx + dy * dy <= this.radius * this.radius;
            }

            applyForce(fx, fy) {
                this.vx += fx;
                this.vy += fy;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vx *= 0.9; // Damping
                this.vy *= 0.9;
            }
        }

        // Edge class
        class Edge {
            constructor(node1, node2) {
                this.node1 = node1;
                this.node2 = node2;
            }

            draw() {
                const gradient = ctx.createLinearGradient(
                    this.node1.x, this.node1.y,
                    this.node2.x, this.node2.y
                );
                gradient.addColorStop(0, this.node1.color);
                gradient.addColorStop(1, this.node2.color);

                ctx.strokeStyle = gradient;
                ctx.lineWidth = 3;
                ctx.shadowColor = 'rgba(102, 126, 234, 0.5)';
                ctx.shadowBlur = 10;

                ctx.beginPath();
                ctx.moveTo(this.node1.x, this.node1.y);
                ctx.lineTo(this.node2.x, this.node2.y);
                ctx.stroke();

                // Arrow
                const angle = Math.atan2(this.node2.y - this.node1.y, this.node2.x - this.node1.x);
                const arrowSize = 15;
                const endX = this.node2.x - Math.cos(angle) * this.node2.radius;
                const endY = this.node2.y - Math.sin(angle) * this.node2.radius;

                ctx.fillStyle = this.node2.color;
                ctx.beginPath();
                ctx.moveTo(endX, endY);
                ctx.lineTo(
                    endX - arrowSize * Math.cos(angle - Math.PI / 6),
                    endY - arrowSize * Math.sin(angle - Math.PI / 6)
                );
                ctx.lineTo(
                    endX - arrowSize * Math.cos(angle + Math.PI / 6),
                    endY - arrowSize * Math.sin(angle + Math.PI / 6)
                );
                ctx.closePath();
                ctx.fill();
            }
        }

        // Physics simulation
        function applyForces() {
            const repulsionStrength = 5000;
            const attractionStrength = 0.01;
            const idealDistance = 200;

            // Node-node repulsion
            for (let i = 0; i < nodes.length; i++) {
                for (let j = i + 1; j < nodes.length; j++) {
                    const dx = nodes[j].x - nodes[i].x;
                    const dy = nodes[j].y - nodes[i].y;
                    const distance = Math.sqrt(dx * dx + dy * dy) || 1;

                    if (distance < 300) {
                        const force = repulsionStrength / (distance * distance);
                        const fx = (dx / distance) * force;
                        const fy = (dy / distance) * force;

                        nodes[i].applyForce(-fx, -fy);
                        nodes[j].applyForce(fx, fy);
                    }
                }
            }

            // Edge attraction
            edges.forEach(edge => {
                const dx = edge.node2.x - edge.node1.x;
                const dy = edge.node2.y - edge.node1.y;
                const distance = Math.sqrt(dx * dx + dy * dy) || 1;
                const force = (distance - idealDistance) * attractionStrength;

                const fx = (dx / distance) * force;
                const fy = (dy / distance) * force;

                edge.node1.applyForce(fx, fy);
                edge.node2.applyForce(-fx, -fy);
            });

            // Center attraction
            const centerX = width / 2;
            const centerY = height / 2;
            nodes.forEach(node => {
                const dx = centerX - node.x;
                const dy = centerY - node.y;
                node.applyForce(dx * 0.0001, dy * 0.0001);
            });

            nodes.forEach(node => node.update());
        }

        // Render
        function render() {
            ctx.clearRect(0, 0, width, height);

            ctx.save();
            ctx.translate(camera.x, camera.y);
            ctx.scale(camera.zoom, camera.zoom);

            // Draw edges
            edges.forEach(edge => edge.draw());

            // Draw nodes
            nodes.forEach(node => node.draw());

            // Draw connecting line
            if (connectMode && connectStart && lastMouseX && lastMouseY) {
                const worldX = (lastMouseX - camera.x) / camera.zoom;
                const worldY = (lastMouseY - camera.y) / camera.zoom;

                ctx.strokeStyle = 'rgba(102, 126, 234, 0.6)';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(connectStart.x, connectStart.y);
                ctx.lineTo(worldX, worldY);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            ctx.restore();
        }

        // Animation loop
        function animate() {
            applyForces();
            render();
            updateStats();
            requestAnimationFrame(animate);
        }

        // Mouse handling
        function getWorldCoordinates(clientX, clientY) {
            const rect = canvas.getBoundingClientRect();
            const x = (clientX - rect.left - camera.x) / camera.zoom;
            const y = (clientY - rect.top - camera.y) / camera.zoom;
            return { x, y };
        }

        canvas.addEventListener('mousedown', (e) => {
            const { x, y } = getWorldCoordinates(e.clientX, e.clientY);

            const clickedNode = nodes.find(node => node.contains(x, y));

            if (e.shiftKey && selectedNode) {
                connectMode = true;
                connectStart = selectedNode;
            } else if (clickedNode) {
                if (e.shiftKey && connectMode && connectStart) {
                    // Create edge
                    if (connectStart !== clickedNode) {
                        const existingEdge = edges.find(e =>
                            (e.node1 === connectStart && e.node2 === clickedNode) ||
                            (e.node1 === clickedNode && e.node2 === connectStart)
                        );

                        if (!existingEdge) {
                            edges.push(new Edge(connectStart, clickedNode));
                        }
                    }
                    connectMode = false;
                    connectStart = null;
                } else {
                    draggedNode = clickedNode;
                    selectedNode = clickedNode;
                    updateSidebar();
                }
            } else {
                isDraggingCanvas = true;
                selectedNode = null;
                updateSidebar();
            }

            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        });

        canvas.addEventListener('mousemove', (e) => {
            const { x, y } = getWorldCoordinates(e.clientX, e.clientY);

            if (draggedNode) {
                draggedNode.x = x;
                draggedNode.y = y;
                draggedNode.vx = 0;
                draggedNode.vy = 0;
            } else if (isDraggingCanvas) {
                camera.x += e.clientX - lastMouseX;
                camera.y += e.clientY - lastMouseY;
            }

            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        });

        canvas.addEventListener('mouseup', () => {
            draggedNode = null;
            isDraggingCanvas = false;
        });

        canvas.addEventListener('dblclick', (e) => {
            const { x, y } = getWorldCoordinates(e.clientX, e.clientY);
            const clickedNode = nodes.find(node => node.contains(x, y));

            if (clickedNode) {
                const newText = prompt('ç·¨è¼¯ç¯€é»å…§å®¹:', clickedNode.text);
                if (newText !== null) {
                    clickedNode.text = newText;
                    saveToLocalStorage();
                }
            } else {
                nodes.push(new Node(x, y));
                saveToLocalStorage();
            }
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            const newZoom = Math.max(0.1, Math.min(3, camera.zoom * delta));

            const { x, y } = getWorldCoordinates(e.clientX, e.clientY);

            camera.x = e.clientX - x * newZoom;
            camera.y = e.clientY - y * newZoom;
            camera.zoom = newZoom;
        });

        // Keyboard
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Delete' && selectedNode) {
                deleteNode();
            } else if (e.key === 'Escape') {
                connectMode = false;
                connectStart = null;
                selectedNode = null;
                updateSidebar();
            }
        });

        // Functions
        function addNode() {
            const x = (width / 2 - camera.x) / camera.zoom;
            const y = (height / 2 - camera.y) / camera.zoom;
            nodes.push(new Node(x, y));
            saveToLocalStorage();
        }

        function autoLayout() {
            if (nodes.length === 0) return;

            const centerX = (width / 2 - camera.x) / camera.zoom;
            const centerY = (height / 2 - camera.y) / camera.zoom;

            if (nodes.length === 1) {
                nodes[0].x = centerX;
                nodes[0].y = centerY;
                return;
            }

            // Create hierarchy based on connections
            const rootNodes = nodes.filter(node =>
                !edges.some(edge => edge.node2 === node)
            );

            if (rootNodes.length === 0) {
                // Circular layout
                const radius = Math.min(width, height) / 3 / camera.zoom;
                nodes.forEach((node, i) => {
                    const angle = (i / nodes.length) * Math.PI * 2;
                    node.x = centerX + Math.cos(angle) * radius;
                    node.y = centerY + Math.sin(angle) * radius;
                    node.vx = 0;
                    node.vy = 0;
                });
            } else {
                // Hierarchical layout
                const levels = new Map();

                function getLevel(node, level = 0) {
                    if (!levels.has(node) || levels.get(node) > level) {
                        levels.set(node, level);
                        edges.filter(e => e.node1 === node).forEach(e => {
                            getLevel(e.node2, level + 1);
                        });
                    }
                }

                rootNodes.forEach(root => getLevel(root));
                nodes.forEach(node => {
                    if (!levels.has(node)) levels.set(node, 0);
                });

                const levelArrays = {};
                levels.forEach((level, node) => {
                    if (!levelArrays[level]) levelArrays[level] = [];
                    levelArrays[level].push(node);
                });

                const maxLevel = Math.max(...Array.from(levels.values()));
                const levelHeight = Math.min(height / (maxLevel + 2), 200) / camera.zoom;

                Object.entries(levelArrays).forEach(([level, nodes]) => {
                    const levelWidth = Math.min(width / (nodes.length + 1), 300) / camera.zoom;
                    nodes.forEach((node, i) => {
                        node.x = centerX + (i - nodes.length / 2 + 0.5) * levelWidth;
                        node.y = centerY + (parseInt(level) - maxLevel / 2) * levelHeight;
                        node.vx = 0;
                        node.vy = 0;
                    });
                });
            }

            saveToLocalStorage();
        }

        function toggleSidebar() {
            document.getElementById('sidebar').classList.toggle('open');
        }

        function updateSidebar() {
            const sidebar = document.getElementById('sidebar');
            if (selectedNode) {
                document.getElementById('nodeText').value = selectedNode.text;
                document.getElementById('nodeSize').value = selectedNode.radius;

                document.querySelectorAll('.color-option').forEach(option => {
                    option.classList.toggle('selected', option.dataset.color === selectedNode.color);
                });

                sidebar.classList.add('open');
            } else {
                sidebar.classList.remove('open');
            }
        }

        function updateNode() {
            if (!selectedNode) return;

            selectedNode.text = document.getElementById('nodeText').value;
            selectedNode.radius = parseInt(document.getElementById('nodeSize').value);

            const selectedColor = document.querySelector('.color-option.selected');
            if (selectedColor) {
                selectedNode.color = selectedColor.dataset.color;
            }

            saveToLocalStorage();
        }

        function deleteNode() {
            if (!selectedNode) return;

            edges = edges.filter(e => e.node1 !== selectedNode && e.node2 !== selectedNode);
            nodes = nodes.filter(n => n !== selectedNode);
            selectedNode = null;
            updateSidebar();
            saveToLocalStorage();
        }

        function clearCanvas() {
            if (confirm('ç¢ºå®šè¦æ¸…é™¤æ‰€æœ‰å…§å®¹å—ï¼Ÿ')) {
                nodes = [];
                edges = [];
                selectedNode = null;
                updateSidebar();
                saveToLocalStorage();
            }
        }

        function updateStats() {
            document.getElementById('nodeCount').textContent = nodes.length;
            document.getElementById('edgeCount').textContent = edges.length;
            document.getElementById('zoomLevel').textContent = Math.round(camera.zoom * 100) + '%';
        }

        function saveToLocalStorage() {
            const data = {
                nodes: nodes.map(n => ({
                    x: n.x, y: n.y, text: n.text, color: n.color, radius: n.radius
                })),
                edges: edges.map(e => ({
                    node1: nodes.indexOf(e.node1),
                    node2: nodes.indexOf(e.node2)
                }))
            };
            localStorage.setItem('mindmap', JSON.stringify(data));
        }

        function loadFromLocalStorage() {
            const data = localStorage.getItem('mindmap');
            if (data) {
                const parsed = JSON.parse(data);
                nodes = parsed.nodes.map(n => new Node(n.x, n.y, n.text, n.color, n.radius));
                edges = parsed.edges.map(e => new Edge(nodes[e.node1], nodes[e.node2]));
            }
        }

        function saveToFile() {
            const data = {
                nodes: nodes.map(n => ({
                    x: n.x, y: n.y, text: n.text, color: n.color, radius: n.radius
                })),
                edges: edges.map(e => ({
                    node1: nodes.indexOf(e.node1),
                    node2: nodes.indexOf(e.node2)
                }))
            };

            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `mindmap_${new Date().getTime()}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function loadFromFile() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const data = JSON.parse(event.target.result);
                        nodes = data.nodes.map(n => new Node(n.x, n.y, n.text, n.color, n.radius));
                        edges = data.edges.map(e => new Edge(nodes[e.node1], nodes[e.node2]));
                        saveToLocalStorage();
                    } catch (error) {
                        alert('è¼‰å…¥å¤±æ•—ï¼Œæª”æ¡ˆæ ¼å¼éŒ¯èª¤ï¼');
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }

        function exportImage() {
            // Calculate bounds
            if (nodes.length === 0) return;

            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            nodes.forEach(node => {
                minX = Math.min(minX, node.x - node.radius);
                minY = Math.min(minY, node.y - node.radius);
                maxX = Math.max(maxX, node.x + node.radius);
                maxY = Math.max(maxY, node.y + node.radius);
            });

            const padding = 50;
            const exportWidth = maxX - minX + padding * 2;
            const exportHeight = maxY - minY + padding * 2;

            const exportCanvas = document.createElement('canvas');
            exportCanvas.width = exportWidth;
            exportCanvas.height = exportHeight;
            const exportCtx = exportCanvas.getContext('2d');

            // Background
            exportCtx.fillStyle = '#1a1a2e';
            exportCtx.fillRect(0, 0, exportWidth, exportHeight);

            // Save original context
            const originalCtx = ctx;
            window.ctx = exportCtx;

            exportCtx.save();
            exportCtx.translate(-minX + padding, -minY + padding);

            edges.forEach(edge => edge.draw());
            nodes.forEach(node => node.draw());

            exportCtx.restore();

            // Restore context
            window.ctx = originalCtx;

            // Download
            exportCanvas.toBlob(blob => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `mindmap_${new Date().getTime()}.png`;
                a.click();
                URL.revokeObjectURL(url);
            });
        }

        function closeTutorial() {
            document.getElementById('tutorial').style.display = 'none';
        }

        function goHome() {
            window.location.href = 'index.html';
        }

        // Color picker
        document.querySelectorAll('.color-option').forEach(option => {
            option.addEventListener('click', () => {
                document.querySelectorAll('.color-option').forEach(o => o.classList.remove('selected'));
                option.classList.add('selected');
                if (selectedNode) {
                    selectedNode.color = option.dataset.color;
                    saveToLocalStorage();
                }
            });
        });

        // Window resize
        window.addEventListener('resize', () => {
            width = window.innerWidth;
            height = window.innerHeight - 70;
            canvas.width = width;
            canvas.height = height;
        });

        // Initialize
        loadFromLocalStorage();

        // Demo content
        if (nodes.length === 0) {
            const centerX = width / 2;
            const centerY = height / 2;

            const root = new Node(centerX, centerY - 150, 'MindFlow', '#667eea', 60);
            const child1 = new Node(centerX - 200, centerY + 50, 'å‰µæ„ç™¼æƒ³', '#764ba2', 50);
            const child2 = new Node(centerX + 200, centerY + 50, 'çŸ¥è­˜æ•´ç†', '#4facfe', 50);
            const child3 = new Node(centerX, centerY + 200, 'å­¸ç¿’ç­†è¨˜', '#43e97b', 50);

            nodes.push(root, child1, child2, child3);
            edges.push(new Edge(root, child1), new Edge(root, child2), new Edge(root, child3));

            saveToLocalStorage();
        }

        animate();
    </script>
</body>
</html>
